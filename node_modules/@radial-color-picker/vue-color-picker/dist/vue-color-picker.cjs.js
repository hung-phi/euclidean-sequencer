'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fillColorWheel = _interopDefault(require('@radial-color-picker/color-wheel'));
var Rotator = _interopDefault(require('@radial-color-picker/rotator'));

//
var script = {
  rcp: null,
  name: 'vue-color-picker',
  props: {
    hue: {
      default: 0
    },
    saturation: {
      default: 100
    },
    luminosity: {
      default: 50
    },
    alpha: {
      default: 1
    },
    step: {
      default: 2
    },
    mouseScroll: {
      default: false
    },
    variant: {
      default: 'collapsible' // collapsible | persistent

    },
    disabled: {
      default: false
    }
  },

  data: function data() {
    return {
      isPaletteIn: true,
      isKnobIn: true,
      isPressed: false,
      isRippling: false,
      isDragging: false
    };
  },

  computed: {
    color: function color() {
      return ("hsla(" + (this.hue) + ", " + (this.saturation) + "%, " + (this.luminosity) + "%, " + (this.alpha) + ")");
    }

  },
  watch: {
    hue: function (angle) {
      this.rcp.angle = angle;
    }
  },

  mounted: function mounted() {
    var this$1 = this;

    if (this.mouseScroll) {
      this.$refs.rotator.addEventListener('wheel', this.onScroll);
    }

    var isConicGradientSupported = getComputedStyle(this.$refs.palette).backgroundImage.includes('conic'); // ignore conic-gradient support & polyfill

    /* istanbul ignore else */

    if (!isConicGradientSupported) {
      fillColorWheel(this.$refs.palette.firstElementChild, this.$el.offsetWidth || 280);
    }

    this.rcp = new Rotator(this.$refs.rotator, {
      angle: this.hue,
      onRotate: this.updateColor,
      onDragStart: function () {
        this$1.isDragging = true;
      },
      onDragStop: function () {
        this$1.isDragging = false;
      }
    });
  },

  methods: {
    onScroll: function onScroll(ev) {
      if (this.isPressed || !this.isKnobIn) { return; }
      ev.preventDefault();

      if (ev.deltaY > 0) {
        this.rcp.angle += this.step;
      } else {
        this.rcp.angle -= this.step;
      }

      this.updateColor(this.rcp.angle);
    },

    rotate: function rotate(ev, isIncrementing) {
      if (this.disabled || this.isPressed || !this.isKnobIn) { return; }
      var multiplier = isIncrementing ? 1 : -1;

      if (ev.ctrlKey) {
        multiplier *= 6;
      } else if (ev.shiftKey) {
        multiplier *= 3;
      }

      this.rcp.angle += this.step * multiplier;
      this.updateColor(this.rcp.angle);
    },

    updateColor: function updateColor(hue) {
      this.$emit('input', hue);
    },

    rotateToMouse: function rotateToMouse(ev) {
      if (this.isPressed || !this.isKnobIn) { return; }
      this.rcp.setAngleFromEvent(ev);
    },

    selectColor: function selectColor() {
      this.isPressed = true;

      if (this.isPaletteIn && this.isKnobIn) {
        this.$emit('change', this.hue);
        this.isRippling = true;
      } else {
        this.isPaletteIn = true;
      }
    },

    togglePicker: function togglePicker() {
      if (this.variant !== 'persistent') {
        if (this.isKnobIn) {
          this.isKnobIn = false;
        } else {
          this.isKnobIn = true;
          this.isPaletteIn = true;
        }
      }

      this.isRippling = false;
      this.isPressed = false;
    },

    hidePalette: function hidePalette() {
      if (!this.isKnobIn) {
        this.isPaletteIn = false;
      }
    }

  },

  beforeDestroy: function beforeDestroy() {
    this.rcp.destroy();
    this.rcp = null;
  }

};

/* script */
            var __vue_script__ = script;
/* template */
var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"rcp",class:{ 'dragging': _vm.isDragging, 'disabled': _vm.disabled },attrs:{"tabindex":_vm.disabled ? -1 : 0},on:{"keyup":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.selectColor($event)},"keydown":[function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])&&_vm._k($event.keyCode,"right",39,$event.key,["Right","ArrowRight"])){ return null; }if('button' in $event && $event.button !== 2){ return null; }$event.preventDefault();_vm.rotate($event, true);},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])&&_vm._k($event.keyCode,"left",37,$event.key,["Left","ArrowLeft"])){ return null; }if('button' in $event && $event.button !== 0){ return null; }$event.preventDefault();_vm.rotate($event, false);}]}},[_c('div',{ref:"palette",staticClass:"rcp__palette",class:_vm.isPaletteIn ? 'in' : 'out'},[_c('canvas')]),_vm._v(" "),_c('div',{ref:"rotator",staticClass:"rcp__rotator",style:({ 'pointer-events': _vm.disabled || _vm.isPressed || !_vm.isKnobIn ? 'none' : null }),on:{"dblclick":function($event){if($event.target !== $event.currentTarget){ return null; }return _vm.rotateToMouse($event)}}},[_c('div',{staticClass:"rcp__knob",class:_vm.isKnobIn ? 'in' : 'out',on:{"transitionend":_vm.hidePalette}})]),_vm._v(" "),_c('div',{staticClass:"rcp__ripple",class:{ 'rippling': _vm.isRippling },style:({ borderColor: _vm.color })}),_vm._v(" "),_c('button',{staticClass:"rcp__well",class:{ 'pressed': _vm.isPressed },style:({ backgroundColor: _vm.color }),attrs:{"type":"button"},on:{"animationend":_vm.togglePicker,"click":_vm.selectColor}})])};
var __vue_staticRenderFns__ = [];

  /* style */
  var __vue_inject_styles__ = undefined;
  /* scoped */
  var __vue_scope_id__ = undefined;
  /* module identifier */
  var __vue_module_identifier__ = undefined;
  /* functional template */
  var __vue_is_functional_template__ = false;
  /* component normalizer */
  function __vue_normalize__(
    template, style, script$$1,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
  ) {
    var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "ColorPicker.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) { component.functional = true; }
    }

    component._scopeId = scope;

    return component
  }
  /* style inject */
  
  /* style inject SSR */
  

  
  var ColorPicker = __vue_normalize__(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    undefined,
    undefined
  );

module.exports = ColorPicker;
